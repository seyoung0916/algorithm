# SWEA 1953 (탈주범 검거)
:pushpin: 유형  
* BFS  

:question: 문제  
* 터널끼리 연결된 경우 이동 가능    
* 탈주범이 있을 수 있는 위치 개수 계산    
* 시간당 1씩 움직임
* 1시간 후 맨홀 위치에 있음  

:heavy_check_mark: 해결  
* bfs()  
	-> 현재 위치 R, C 방문 처리, q에 push  
	-> while 문을 통해 정해진 시간까지 반복  
	-> 시간이 되면 방문된 개수 세기 (result)
	-> 큐 크기만큼 반복 (이전 큐 크기 변수에 저장)  
	-> 현재 파이프에서 갈 수 없는 방향은 제외 (dx, dy)  
	-> 걸러진 방향에 대해서 다음 좌표를 구함  
	-> 범위, 방문, 파이프 존재 여부를 확인하고  
	-> 각 방향에 따라 올 수 있는 파이프를 제한

:heavy_plus_sign: 추가
* 처음 생각한 방법  
  * 각 위치의 파이프 번호를 구하고, 파이프 방향에 따라 올 수 있는 다음 파이프 번호를 체크  
    -> 코드가 길어지고 헷갈림  
* 새로 바꾼 방법  
  * 각 위치의 파이프 번호에 대해 모든 방향을 체크  
    -> 파이프 번호일 때 && (안되는 방향 || 방향2) 이런 식으로 다음으로 갈 수 있는 방향 체크  
	-> 다음 좌표에 있는 파이프 번호가 올 수 있는 위치인지 체크 (방향에 따라 올 수 있는 파이프가 다름)  

---  

# 프로그래머스 49993 (스킬트리)
:pushpin: 유형  
* 간단한 시뮬레이션(?)  

:question: 문제  
* 스킬 트리 가능한 개수 체크  
* 선행 skill에 대해 skill_trees의 문자열이 가능한지를 체크  
* skill의 순서는 지켜져야 함  
	-> 순서에 없는 스킬은 상관없음  

:heavy_check_mark: 해결  
* v를 skill 길이만큼 -1 로 채움 (인덱스가 존재하지 않는다고 가정)  
* skill의 문자가 skill_trees[i]의 어디에(인덱스) 존재하는지를 체크해 v에 저장  
* flag를 지정해 skill tree가 정상이라고 가정  
	-> 현재 원소(v[j])가 -1이 아닌 경우  
		1) 이전 인덱스가 현재보다 크면 비정상  
		2) 이전 인덱스가 -1이면 선행 스킬을 안 찍은 것이므로 비정상  

---  

# 프로그래머스 17676 (추석 트래픽)
:pushpin: 유형  
* 문자열 처리  

:question: 문제  
* 주어진 응답 완료 시간, 오차범위로 응답 기간을 구할 것  
	-> 15일 이전으로 넘어가는 것 처리를 어떻게 해야할 지 고민  
* 각 구간에 대해 초당 처리양이 최대일 때 개수를 구하기  
* 문자 <-> 숫자로 계속 변환하면서 꼬여버려서 다시 새로 품  

:heavy_check_mark: 해결  
* strtok(string str, delim = ‘ ‘)  
	-> 공백 기준으로 vector에 담음  
	-> tmp에 날짜, 응답완료 시간, 처리시간 이 담겨있음    
* 문자열 처리  
	-> tstr : ‘:’를 기준으로 시, 분, 초가 담김 -> 초로 변환  
	-> double t : 처리 시간의 s 단위 뺀 것  
* 시작 시간, 종료시간 -> v에 push_back  
	-> s(종료 시간) – t + 0.001, s  
* 모든 구간을 탐색 X  
	-> 완료 시간 순으로 오름차순 되어 있음  
	-> 현재를 기준으로 다음 시작 시간들이 현재 완료 시점 + 1 초 이내에 존재하는지 체크  

---  
